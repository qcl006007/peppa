(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{526:function(e,r,t){"use strict";t.r(r);var a=t(6),s=Object(a.a)({},(function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"git-基础认知"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#git-基础认知"}},[e._v("#")]),e._v(" Git 基础认知")]),e._v(" "),t("h2",{attrs:{id:"git-提交历史管理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#git-提交历史管理"}},[e._v("#")]),e._v(" Git 提交历史管理")]),e._v(" "),t("h3",{attrs:{id:"merge"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#merge"}},[e._v("#")]),e._v(" merge")]),e._v(" "),t("p",[e._v("merge 是用于merge其中一个分支的提交到另一个分支，常见的操作方法：")]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("git checkout your_branch\n\ngit merge master\n\n#git merge origin/master\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br")])]),t("p",[t("img",{attrs:{src:"/images/git_01_merge.jpg",alt:""}})]),e._v(" "),t("p",[e._v("merge 的优势保留了该分支的改动提交记录，历史提交目录，但频繁的merge会导致整个commit历史目录比较混乱。")]),e._v(" "),t("h3",{attrs:{id:"rebase"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rebase"}},[e._v("#")]),e._v(" rebase")]),e._v(" "),t("p",[e._v("rebase 具有和merge相同的功能，它会把所有的提交压缩成一个patch,然后把patch添加到目标分支里，使之具有结构清晰的提交历史目录。")]),e._v(" "),t("p",[t("img",{attrs:{src:"/images/git_01_rebase.jpg",alt:""}})]),e._v(" "),t("h3",{attrs:{id:"merge-与-rebase-的使用场景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#merge-与-rebase-的使用场景"}},[e._v("#")]),e._v(" merge 与 rebase 的使用场景")]),e._v(" "),t("ol",[t("li",[e._v("git merge：")])]),e._v(" "),t("ul",[t("li",[e._v("记录下合并动作，很多时候这种合并动作是垃圾信息")]),e._v(" "),t("li",[e._v("不会修改原 commit ID")]),e._v(" "),t("li",[e._v("冲突只解决一次")]),e._v(" "),t("li",[e._v("分支看着不大整洁，但是能看出合并的先后顺序")]),e._v(" "),t("li",[e._v("记录了真实的 commit 情况，包括每个分支的详情")])]),e._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[e._v("git rebase")])]),e._v(" "),t("ul",[t("li",[e._v("改变当前分支 branch out 的位置")]),e._v(" "),t("li",[e._v("得到更简洁的项目历史")]),e._v(" "),t("li",[e._v("每个 commit 都需要解决冲突")]),e._v(" "),t("li",[e._v("修改所有 commit ID")])]),e._v(" "),t("p",[e._v("随着团队增长，通过 merge 策略很难管理和追踪到每个提交。为了提交历史更清晰、更易于理解，使用 rebase 是一个明智、高效的选择。")]),e._v(" "),t("p",[e._v("下面是针对不同环境的建议，可以最大限度地发挥 rebase 的优势：")]),e._v(" "),t("p",[e._v("本地开发：如果你没有和别人协同工作，你应该使用 rebasing 而不是 merging ，这样历史记录会很清晰。如果你已经从仓库拉取了你的个人 fork，并且不准备和别的开发者一起工作，在分支 push 前 rebase 也是可以的。")]),e._v(" "),t("p",[e._v("你的代码准备好了被 review ：你创建了 pull request。别人正在 review 你的代码，可能把它拉到了本地 review 。如果这样，你最好别 rebase 你的代码。你应该创建一个 “rework” 提交来更新你的 feature 分支。它会让 pull request 的可塑性更强，也能避免历史突然丢失。")]),e._v(" "),t("p",[e._v('review 已经完成并且已经准备好了合并到目标分支。恭喜！你就要删除你的 feature 分支了。由于别的开发者不需要拉取、合并这些更改，这是你清理记录的好机会。你可以改写记录，折叠原始提交、“pr rework”  提交和 "merge" 提交，使之成为一整个清晰的提交。作为可选，你还可以给这些提交创建一个明确的 merge ，这样做实际上很有用。它会记录 feature 并入 master 的时间。')]),e._v(" "),t("h2",{attrs:{id:"参考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[e._v("#")]),e._v(" 参考")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://mp.weixin.qq.com/s/dAM5aGIa7VErvIJUgImdqg",target:"_blank",rel:"noopener noreferrer"}},[e._v("git rebase 和 merge 的区别"),t("OutboundLink")],1)])])])}),[],!1,null,null,null);r.default=s.exports}}]);