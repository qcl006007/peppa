(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{511:function(a,n,l){"use strict";l.r(n);var e=l(6),i=Object(e.a)({},(function(){var a=this,n=a.$createElement,l=a._self._c||n;return l("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[l("h2",{attrs:{id:"webpack-plugin"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#webpack-plugin"}},[a._v("#")]),a._v(" Webpack plugin")]),a._v(" "),l("h3",{attrs:{id:"loader和plugin的区别"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#loader和plugin的区别"}},[a._v("#")]),a._v(" Loader和Plugin的区别")]),a._v(" "),l("ul",[l("li",[a._v("loader: 顾名思义，某种类型资源文件的加载器，作用于某种类型的文件上。webpack 本身也是不能直接打包这些非 js 文件的，需要一个转化器即 loader。 loader 本身是单一，简单的，不能将多个功能放在一个loader里。")]),a._v(" "),l("li",[a._v("plugin: plugin 比 loaders 更加先进一点，你可以扩展 webpack 的功能来满足自己的需要。当 loader 不能满足的时候，就需要 plugin 了。")])]),a._v(" "),l("p",[a._v("loader 用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。包括：打包优化，资源管理，注入环境变量。")]),a._v(" "),l("h3",{attrs:{id:"plugin"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#plugin"}},[a._v("#")]),a._v(" Plugin")]),a._v(" "),l("p",[a._v("常见的Plugin插件有：MiniCssExtractPlugin, HtmlWebpackPlugin, CopyWebpackPlugin等等。")]),a._v(" "),l("p",[a._v("webpack 插件是一个具有 apply 方法的 JavaScript 对象。apply 方法会被 webpack compiler 调用，并且在 整个 编译生命周期都可以访问 compiler 对象。")]),a._v(" "),l("p",[a._v("官网的例子：")]),a._v(" "),l("div",{staticClass:"language- line-numbers-mode"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[a._v("const pluginName = 'ConsoleLogOnBuildWebpackPlugin';\n\nclass ConsoleLogOnBuildWebpackPlugin {\n  apply(compiler) {\n    compiler.hooks.run.tap(pluginName, (compilation) => {\n      console.log('webpack 构建过程开始！');\n    });\n  }\n}\n\nmodule.exports = ConsoleLogOnBuildWebpackPlugin;\n\n")])]),a._v(" "),l("div",{staticClass:"line-numbers-wrapper"},[l("span",{staticClass:"line-number"},[a._v("1")]),l("br"),l("span",{staticClass:"line-number"},[a._v("2")]),l("br"),l("span",{staticClass:"line-number"},[a._v("3")]),l("br"),l("span",{staticClass:"line-number"},[a._v("4")]),l("br"),l("span",{staticClass:"line-number"},[a._v("5")]),l("br"),l("span",{staticClass:"line-number"},[a._v("6")]),l("br"),l("span",{staticClass:"line-number"},[a._v("7")]),l("br"),l("span",{staticClass:"line-number"},[a._v("8")]),l("br"),l("span",{staticClass:"line-number"},[a._v("9")]),l("br"),l("span",{staticClass:"line-number"},[a._v("10")]),l("br"),l("span",{staticClass:"line-number"},[a._v("11")]),l("br"),l("span",{staticClass:"line-number"},[a._v("12")]),l("br")])]),l("h3",{attrs:{id:"compiler-compilation"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#compiler-compilation"}},[a._v("#")]),a._v(" compiler Compilation")]),a._v(" "),l("p",[a._v("在插件开发中最重要的两个资源就是 compiler 和 compilation 对象。理解它们的角色是扩展 webpack 引擎重要的第一步。")]),a._v(" "),l("ul",[l("li",[l("p",[a._v("compiler 对象代表了完整的 webpack 环境配置。这个对象在启动 webpack 时被一次性建立，并配置好所有可操作的设置，包括 options，loader 和 plugin。当在 webpack 环境中应用一个插件时，插件将收到此 compiler 对象的引用。可以使用它来访问 webpack 的主环境。")])]),a._v(" "),l("li",[l("p",[a._v("compilation 对象代表了一次资源版本构建。当运行 webpack 开发环境中间件时，每当检测到一个文件变化，就会创建一个新的 compilation，从而生成一组新的编译资源。一个 compilation 对象表现了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态信息。compilation 对象也提供了很多关键时机的回调，以供插件做自定义处理时选择使用。")])])]),a._v(" "),l("h3",{attrs:{id:"手写plugin"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#手写plugin"}},[a._v("#")]),a._v(" 手写Plugin")]),a._v(" "),l("p",[a._v("目前Webpack最新的版本是5.0，一些钩子hook也发生了变化，按照最新的api，实现一个加banner的plugin，用作练习。")]),a._v(" "),l("p",[a._v("在手写plugin之前，我们再对整个webpack的编译过程进行一次梳理：\n"),l("img",{attrs:{src:"/images/webpack_01.png",alt:""}})]),a._v(" "),l("p",[a._v("未完待续---")])])}),[],!1,null,null,null);n.default=i.exports}}]);